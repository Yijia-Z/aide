/**
* Component properties for RenderMessage.
 * 
 * @interface RenderMessageProps
 * @property {Message} message - The message object to render.
 * @property {string} threadId - The ID of the thread containing the message.
 * 
 * @property {number} [depth=0] - The depth of the message in the thread hierarchy.
 * @property {string | null} [parentId=null] - The ID of the parent message, if any.
 * @property {Thread[]} threads - The list of all threads.
 * @property {string | null} currentThread - The ID of the currently selected thread.
 * @property {{ [key: string]: string | null }} selectedMessages - The currently selected messages by thread ID.
 * @property {string | null} editingMessage - The ID of the message currently being edited.
 * @property {string} editingContent - The content of the message currently being edited.
 * @property {string[]} glowingMessageIds - The IDs of messages that are glowing.
 * @property {(id: string) => void} addGlowingMessage - Function to add a message ID to the glowing messages.
 * @property {(id: string) => void} removeGlowingMessage - Function to remove a message ID from the glowing messages.
 * @property {() => void} clearGlowingMessages - Function to clear all glowing messages.
 * @property {{ [key: string]: boolean }} copiedStates - The states of copied code blocks by their IDs.
 * @property {{
*   message: Message;
*   operation: "copy" | "cut";
*   sourceThreadId: string | null;
*   originalMessageId: string | null;
* } | null} clipboardMessage - The message currently in the clipboard.
* @property {{ [key: string]: boolean }} isGenerating - The states of messages being generated by their IDs.
* @property {React.Dispatch<React.SetStateAction<{ [key: string]: string | null }>>} setSelectedMessages - Function to set the selected messages.
* @property {(threadId: string, messageId: string) => void} toggleCollapse - Function to toggle the collapse state of a message.
* @property {(content: string) => void} setEditingContent - Function to set the content of the message being edited.
* @property {(threadId: string, messageId: string) => void} confirmEditingMessage - Function to confirm the editing of a message.
* @property {() => void} cancelEditingMessage - Function to cancel the editing of a message.
* @property {(message: Message) => void} startEditingMessage - Function to start editing a message.
* @property {(threadId: string, parentId: string | null) => void} addEmptyReply - Function to add an empty reply to a message.
* @property {(threadId: string, messageId: string, count: number) => void} generateAIReply - Function to generate an AI reply to a message.
* @property {(threadId: string, messageId: string, operation: "copy" | "cut") => void} copyOrCutMessage - Function to copy or cut a message.
* @property {(threadId: string, parentId: string | null) => void} pasteMessage - Function to paste a message.
* @property {(threadId: string, messageId: string, deleteChildren: boolean | "clear") => void} deleteMessage - Function to delete a message.
* @property {(messages: Message[], id: string) => Message | null} findMessageById - Function to find a message by its ID.
* @property {(messages: Message[], targetId: string, parents?: Message[]) => [Message | null, Message[]]} findMessageAndParents - Function to find a message and its parents by its ID.
* @property {(messages: Message[], messageId: string) => Message[]} getSiblings - Function to get the sibling messages of a message.
* @property {(modelId: string | undefined) => any} getModelDetails - Function to get the details of a model by its ID.
* @property {React.Dispatch<React.SetStateAction<{ [key: string]: boolean }>>} setCopiedStates - Function to set the states of copied code blocks.
* @property {React.Dispatch<React.SetStateAction<Thread[]>>} setThreads - Function to set the list of threads.
* @property {React.Dispatch<React.SetStateAction<{
*   message: Message;
*   operation: "copy" | "cut";
*   sourceThreadId: string | null;
*   originalMessageId: string | null;
* } | null>>} setClipboardMessage - Function to set the message in the clipboard.
* @property {number} lastGenerateCount - The last count of AI replies generated.
* @property {React.Dispatch<React.SetStateAction<number>>} setLastGenerateCount - Function to set the last count of AI replies generated.
*/
/**
* render-message.tsx
* 负责渲染单条消息 + 递归子消息
*/

import React, { useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useInView } from "react-intersection-observer";
import Markdown from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import remarkMath from "remark-math";
import rehypeKatex from "rehype-katex";
import "katex/dist/katex.min.css";
import { Prism, SyntaxHighlighterProps } from "react-syntax-highlighter";
import { gruvboxDark } from "react-syntax-highlighter/dist/esm/styles/prism";
import { cn } from "@/lib/utils";
import Image from "next/image";
import {handleSelectMessage} from "../utils/handleSelectMessage";
import {
  ArrowUp,
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  Edit,
  Trash,
  Trash2,
  MessageSquareReply,
  X,
  Check,
  Copy,
  Scissors,
  ClipboardPaste,
  WandSparkles,
  OctagonX,
  LoaderCircle,
  Plus,
  Minus,
  MessageSquareOff,
  ClipboardType,
  ClipboardCheck,
  ClipboardX,
  Box,
  Bot,
  Reply,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import {
  Menubar,
  MenubarContent,
  MenubarItem,
  MenubarMenu,
  MenubarShortcut,
  MenubarTrigger,
} from "@/components/ui/menubar";
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuTrigger,
} from "@/components/ui/context-menu";
import { Badge } from "@/components/ui/badge";

import { Message, Thread, Tool, ContentPart } from "@/components/types";

interface RenderMessageProps {
  message: Message;
  threadId: string;
  depth?: number;
  parentId?: string | null;
  threads: Thread[];
  currentThread: string | null;
  selectedMessages: { [key: string]: string | null };
  editingMessage: string | null;
  editingContent: string;
  glowingMessageIds: string[];
  addGlowingMessage: (id: string) => void;
  removeGlowingMessage: (id: string) => void;
  clearGlowingMessages: () => void;
  copiedStates: { [key: string]: boolean };
  clipboardMessage: {
    message: Message;
    operation: "copy" | "cut";
    sourceThreadId: string | null;
    originalMessageId: string | null;
  } | null;
  isGenerating: { [key: string]: boolean };
  setSelectedMessages: React.Dispatch<React.SetStateAction<{ [key: string]: string | null }>>;
  toggleCollapse: (threadId: string, messageId: string) => void;
  setEditingContent: (content: string) => void;
  confirmEditingMessage: (threadId: string, messageId: string) => void;
  cancelEditingMessage: () => void;
  startEditingMessage: (message: Message) => void;
  addEmptyReply: (threadId: string, parentId: string | null, publisher?: "user" | "ai") => void;
  generateAIReply: (threadId: string, messageId: string, count: number) => void;
  copyOrCutMessage: (threadId: string, messageId: string, operation: "copy" | "cut") => void;
  pasteMessage: (threadId: string, parentId: string | null) => void;
  deleteMessage: (threadId: string, messageId: string, deleteChildren: boolean | "clear") => void;
  findMessageById: (messages: Message[], id: string) => Message | null;
  findMessageAndParents: (
    messages: Message[],
    targetId: string,
    parents?: Message[]
  ) => [Message | null, Message[]];
  getSiblings: (messages: Message[], messageId: string) => Message[];
  getModelDetails: (modelId: string | undefined) => any;
  setCopiedStates: React.Dispatch<React.SetStateAction<{ [key: string]: boolean }>>;
  setThreads: React.Dispatch<React.SetStateAction<Thread[]>>;
  setClipboardMessage: React.Dispatch<
    React.SetStateAction<{
      message: Message;
      operation: "copy" | "cut";
      sourceThreadId: string | null;
      originalMessageId: string | null;
    } | null>
  >;
  lastGenerateCount: number;
  setLastGenerateCount: React.Dispatch<React.SetStateAction<number>>;
}

// ------------------- 新增: 处理折叠预览文本的函数 -------------------
// 这部分就是替代以前直接 JSON.stringify(...) 的做法
function getPreviewString(content: string | ContentPart[]): string {
  const MAX_LENGTH = 50; // 折叠时只展示前 50 个字符

  if (typeof content === "string") {
    // 如果是纯字符串，就只截取前 50 个字符
    const line = content.split("\n")[0];
    const preview = line.slice(0, MAX_LENGTH);
    return preview + (line.length > MAX_LENGTH ? "..." : "");
  } else {
    // 如果是 ContentPart[]，先找第一段文本类型
    const firstTextPart = content.find(
      (part) => part.type === "text" && part.text.trim().length > 0
    );
    if (firstTextPart && firstTextPart.type === "text") {
      const preview = firstTextPart.text.slice(0, MAX_LENGTH);
      return preview + (firstTextPart.text.length > MAX_LENGTH ? "..." : "");
    }
    // 如果没有 text，就只能做一个简短的 stringify
    const jsonSnippet = JSON.stringify(content).slice(0, MAX_LENGTH);
    return jsonSnippet + (jsonSnippet.length >= MAX_LENGTH ? "..." : "");
  }
}

// 示例：用来在多层 messages/replies 里找到指定 message 并更新 modelName
const updateMessageModelConfig = (
  messages: Message[],
  targetId: string,
  newModelName: string
): Message[] => {
  if (!messages) return [];
  return messages.map((msg) => {
    if (msg.id === targetId) {
      return {
        ...msg,
        modelConfig: { ...msg.modelConfig, name: newModelName },
      };
    }
    if (msg.replies?.length > 0) {
      return {
        ...msg,
        replies: updateMessageModelConfig(msg.replies, targetId, newModelName),
      };
    }
    return msg;
  });
};

const RenderMessage: React.FC<RenderMessageProps> = (props) => {
  const {
    message,
    threadId,
    depth = 0,
    parentId = null,
    threads,
    currentThread,
    selectedMessages,
    editingMessage,
    editingContent,
    glowingMessageIds,
    addGlowingMessage,
    removeGlowingMessage,
    clearGlowingMessages,
    copiedStates,
    clipboardMessage,
    isGenerating,
    setSelectedMessages,
    toggleCollapse,
    setEditingContent,
    confirmEditingMessage,
    cancelEditingMessage,
    startEditingMessage,
    addEmptyReply,
    generateAIReply,
    copyOrCutMessage,
    pasteMessage,
    deleteMessage,
    findMessageById,
    findMessageAndParents,
    getSiblings,
    getModelDetails,
    setCopiedStates,
    setThreads,
    setClipboardMessage,
    lastGenerateCount,
    setLastGenerateCount,
  } = props;

  const SyntaxHighlighter = Prism as unknown as typeof React.Component<SyntaxHighlighterProps>;

  // 是否选中 / 是否选中父
  const selectedMessage = currentThread !== null ? selectedMessages[currentThread] : null;
  const isSelected = selectedMessage === message.id;
  const isParentOfSelected =
    selectedMessage !== null &&
    findMessageById(message.replies, selectedMessage) !== null;
  const isSelectedOrParent = isSelected || isParentOfSelected || parentId === message.id;

  // inView 优化
  const [ref, inView] = useInView({ threshold: 0, rootMargin: "200px 0px" });
  const renderedContentRef = useRef<string | null>(null);
  
  useEffect(() => {
    if (inView && !renderedContentRef.current) {
      if (typeof message.content === "string") {
        renderedContentRef.current = message.content;
      } else {
        renderedContentRef.current = JSON.stringify(message.content);
      }
    }
  }, [inView, message.content]);

  // 获取 thread & siblings
  const currentThreadData = threads.find((t) => t.id === currentThread);
  if (!currentThreadData) return null;

  const [currentMsg, parentMessages] = findMessageAndParents(
    currentThreadData.messages,
    message.id
  );
  const parentMessage =
    parentMessages.length > 0 ? parentMessages[parentMessages.length - 1] : null;
  const siblingsArr = getSiblings(currentThreadData.messages, message.id);
  const currentIndex = siblingsArr.findIndex((m) => m.id === message.id);

  // 折叠 + 展开逻辑
  const getTotalReplies = (msg: Message): number => {
    return msg.replies.reduce((total, r) => total + 1 + getTotalReplies(r), 0);
  };

  // 代码块复制
  const handleCopyCode = (codeString: string, codeBlockId: string) => {
    navigator.clipboard.writeText(codeString);
    setCopiedStates((prev) => ({ ...prev, [codeBlockId]: true }));
    setTimeout(() => {
      setCopiedStates((prev) => ({ ...prev, [codeBlockId]: false }));
    }, 2000);
  };

  // 截断长文本
  const truncateContent = (input: string, keepFull: boolean) => {
    if (keepFull) return input;
    const maxLength = 500;
    const lines = input.split("\n");
    const firstFourLines = lines.slice(0, 4).join("\n");
    if (input.length > maxLength || lines.length > 3) {
      return (
        firstFourLines.slice(0, maxLength) +
        (lines[3]?.startsWith("```") ? "\n" : "") +
        (lines.length > 4 ? "..." : input.length > maxLength ? "..." : "")
      );
    }
    return input;
  };

  const renderMessageContent = (
    content: string | ContentPart[],
    showFull: boolean
  ) => {
    if (typeof content === "string") {
      // 纯文字，走 Markdown
      return (
        <Markdown
          remarkPlugins={[remarkGfm, remarkMath]}
          rehypePlugins={[rehypeRaw, rehypeKatex]}
          components={{
            code({ node, inline, className, children, ...props }: any) {
              const match = /language-(\w+)/.exec(className || "");
              const codeString = String(children).replace(/\n$/, "");
              const codeBlockId = `${message.id}-${match?.[1] || "unknown"
                }-${codeString.slice(0, 32)}`;
              return !inline && match ? (
                <div className="relative">
                  <div className="absolute -top-7 w-full flex justify-between items-center p-1 pl-3 rounded-t-lg border-b-[1.5px] text-[14px] font-[Consolas] border-[#A8998480] bg-[#1D2021] text-[#A89984]">
                    <span>{match[1]}</span>
                    <Button
                      className="rounded-md w-6 h-6 p-0"
                      variant="ghost"
                      size="sm"
                      onClick={() => handleCopyCode(codeString, codeBlockId)}
                    >
                      {copiedStates[codeBlockId] ? (
                        <Check className="h-4 w-4" />
                      ) : (
                        <Copy className="h-4 w-4" />
                      )}
                    </Button>
                  </div>
                  <SyntaxHighlighter
                    className="text-xs"
                    PreTag={"pre"}
                    style={gruvboxDark}
                    language={match[1]}
                    wrapLines
                    showLineNumbers
                    lineProps={{
                      style: { whiteSpace: "pre-wrap", wordBreak: "break-word" },
                    }}
                    {...props}
                  >
                    {codeString}
                  </SyntaxHighlighter>
                </div>
              ) : (
                <code className={className} {...props}>
                  {children}
                </code>
              );
            },
          }}
        >
          {truncateContent(content, showFull)}
        </Markdown>
      );
    } else {
      // ContentPart[]
      return (
        <>
          {content.map((part, idx) => {
            if (part.type === "text") {
              return (
                <Markdown
                  key={idx}
                  remarkPlugins={[remarkGfm, remarkMath]}
                  rehypePlugins={[rehypeRaw, rehypeKatex]}
                >
                  {truncateContent(part.text, showFull)}
                </Markdown>
              );
            } else if (part.type === "image_url") {
              return (
                <div key={idx} className="my-2">
                  <Image
                    src={part.image_url.url}
                    alt={part.image_url.detail || "image"}
                    width={500}
                    height={300}
                    className="max-w-[50%] rounded shadow-sm"
                  />
                  {part.image_url.detail && (
                    <div className="text-sm text-muted-foreground italic">
                      {part.image_url.detail}
                    </div>
                  )}
                </div>
              );
            }
            return null;
          })}
        </>
      );
    }
  };

  // 计算缩进
  const indent =
    depth === 0
      ? 0
      : isSelectedOrParent || siblingsArr.some((s) => s.id === selectedMessage)
        ? -16
        : 0;
  const isGlowing = glowingMessageIds.includes(message.id);

  // 如果要在 runtime 更新 modelName
  const modelDetails = message.modelConfig;
  const modelName = getModelDetails(message.modelId)?.name;
  if (modelName && modelDetails && modelName !== modelDetails.name) {
    setThreads((prevThreads) =>
      prevThreads.map((th) => {
        if (th.id !== currentThread) return th;
        return {
          ...th,
          messages: updateMessageModelConfig(th.messages, message.id, modelName),
        };
      })
    );
  }

  return (
    <motion.div
      ref={ref}
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: 20 }}
      style={{ marginLeft: `${indent}px` }}
      layout="position"
      id={`message-${message.id}`}
      className="mt-2"
    >
      <ContextMenu>
        <ContextMenuTrigger
          disabled={editingMessage === message.id}
          onContextMenu={(e) => {
            if (currentThread && selectedMessages[currentThread] !== message.id) {
              setSelectedMessages((prev) => ({ ...prev, [currentThread]: message.id }));
            }
          }}
        >
          {/* Outer container */}
          <div
            className={cn(
              "flex items-start space-x-1 p-1 rounded-lg",
              isSelectedOrParent ? "custom-shadow" : "text-muted-foreground pb-0",
              siblingsArr.some((s) => s.id === selectedMessage) && "inside-border",
              !selectedMessage && parentId === null && "inside-border",
              isGlowing && "glow-effect"
            )}
            onClick={(e) => {
              e.stopPropagation();
          if (currentThread && selectedMessages[currentThread] !== message.id) {
                setSelectedMessages((prev) => ({ ...prev, [currentThread]: message.id }));
              } 
            }}
          >
            <div className="flex-grow p-0 overflow-hidden">
              <div className="flex flex-col">
                {/* 顶部行：折叠按钮 + publisher */}
                <div
                  className={cn(
                    "flex items-start justify-between rounded-md", // Changed from items-center to items-start
                    isGenerating[message.id] && "opacity-50 glow-effect"
                  )}
                >
                  {/* Left side: collapse button, publisher, badges */}
                  <div className="flex flex-grow items-start gap-2">
                    {/* Collapse button */}
                    <Button
                      variant="outline"
                      className="flex-shrink-0 w-6 h-6 p-0 rounded-md relative"
                      onClick={(e) => {
                        e.stopPropagation();
                        toggleCollapse(threadId, message.id);
                      }}
                    >
                      {message.isCollapsed ? <Plus /> : <Minus />}
                    </Button>

                    {/* Publisher and badges wrapper */}
                    <div className="flex items-center gap-1 flex-wrap">
                      {/* Publisher */}
                      <span
                        className={cn(
                          "font-bold select-none",
                          message.publisher === "ai"
                            ? "text-blue-800 dark:text-blue-600"
                            : "text-green-800 dark:text-green-600"
                        )}
                      >
                        {parentId !== null &&
                          message.publisher === findMessageById(
                            threads.find((tt) => tt.id === currentThread)?.messages || [],
                            parentId
                          )?.publisher && <Reply className="inline-block h-4 w-4" />}
                        {message.publisher === "ai"
                          ? modelDetails?.name || "AI"
                          : message.userName}
                      </span>

                      {/* Model badges */}
                      {modelDetails && (
                        <div className="flex items-center gap-1 flex-wrap">
                          <Badge
                            variant="outline"
                            className="select-none text-muted-foreground gap-1"
                            onClick={(e) => {
                              if (window.innerWidth < 768) {
                                e.stopPropagation();
                                const text = e.currentTarget.querySelector("span");
                                if (text) {
                                  if (!text.style.display) {
                                    text.style.display = "none";
                                  }
                                  text.style.display =
                                    text.style.display === "none" ? "inline" : "none";
                                }
                              }
                            }}
                          >
                            <Bot className="w-3 h-3 m-0.5" />
                            <span>
                              {modelDetails.baseModel?.split("/").pop()?.split("-")[0]}
                            </span>
                          </Badge>
                          {modelDetails.parameters?.tools &&
                            modelDetails.parameters.tools.length > 0 &&
                            modelDetails.parameters.tool_choice !== "none" && (
                              <div className="flex gap-1 flex-wrap">
                                {modelDetails.parameters.tools.map((tl: Tool) => (
                                  <Badge
                                    key={tl.id}
                                    variant={
                                      modelDetails.parameters?.tool_choice === "auto"
                                        ? "outline"
                                        : "secondary"
                                    }
                                    className="select-none cursor-pointer md:cursor-default gap-1"
                                  >
                                    <Box className="w-3 h-3 m-0.5" />
                                    <span className="hidden md:inline">{tl.function.name}</span>
                                  </Badge>
                                ))}
                              </div>
                            )}
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Right side: navigation arrows */}
                  <div
                    className={cn(
                      "flex flex-shrink-0 space-x-1",
                      isSelected ? "opacity-100" : "opacity-0 hover:opacity-100",
                      "transition-opacity duration-200"
                    )}
                  >
                    {parentMessage && (
                      <Button
                        variant="ghost"
                        size="sm"
                        className="w-6 h-6 p-0"
                        onClick={(e) => {
                          e.stopPropagation();
                          setSelectedMessages((prev) => ({
                            ...prev,
                            [String(currentThread)]: parentMessage.id,
                          }));
                        }}
                        onMouseEnter={() => addGlowingMessage(parentMessage.id)}
                        onMouseLeave={() => removeGlowingMessage(parentMessage.id)}
                      >
                        <ArrowLeft className="h-4 w-4" />
                      </Button>
                    )}
                    {currentMsg?.replies && currentMsg.replies.length > 0 && (
                      <Button
                        variant="ghost"
                        size="sm"
                        className="w-6 h-6 p-0"
                        onClick={(e) => {
                          e.stopPropagation();
                          setSelectedMessages((prev) => ({
                            ...prev,
                            [String(currentThread)]: currentMsg.replies[0].id,
                          }));
                        }}
                        onMouseEnter={() => addGlowingMessage(currentMsg.replies[0].id)}
                        onMouseLeave={() => removeGlowingMessage(currentMsg.replies[0].id)}
                      >
                        <ArrowRight className="h-4 w-4" />
                      </Button>
                    )}
                    {siblingsArr[currentIndex - 1] && (
                      <Button
                        variant="ghost"
                        size="sm"
                        className="w-6 h-6 p-0"
                        onClick={(e) => {
                          e.stopPropagation();
                          setSelectedMessages((prev) => ({
                            ...prev,
                            [String(currentThread)]: siblingsArr[currentIndex - 1].id,
                          }));
                        }}
                        onMouseEnter={() => addGlowingMessage(siblingsArr[currentIndex - 1].id)}
                        onMouseLeave={() => removeGlowingMessage(siblingsArr[currentIndex - 1].id)}
                      >
                        <ArrowUp className="h-4 w-4" />
                      </Button>
                    )}
                    {siblingsArr[currentIndex + 1] && (
                      <Button
                        variant="ghost"
                        size="sm"
                        className="w-6 h-6 p-0"
                        onClick={(e) => {
                          e.stopPropagation();
                          setSelectedMessages((prev) => ({
                            ...prev,
                            [String(currentThread)]: siblingsArr[currentIndex + 1].id,
                          }));
                        }}
                        onMouseEnter={() => addGlowingMessage(siblingsArr[currentIndex + 1].id)}
                        onMouseLeave={() => removeGlowingMessage(siblingsArr[currentIndex + 1].id)}
                      >
                        <ArrowDown className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                </div>

                {/* 正文：编辑态 / 普通态 */}
                {editingMessage === message.id ? (
                  <Textarea
                    id={`message-edit-${message.id}`}
                    value={editingContent}
                    onChange={(e) => setEditingContent(e.target.value)}
                    className="min-font-size font-serif flex-grow w-auto m-1 p-0 bg-inherit"
                    style={{
                      height: Math.max(80, Math.min(editingContent.split('\n').length * 24, window.innerHeight * 0.5)),
                      maxHeight: "50vh",
                    }}
                    autoFocus
                  />
                ) : (
                  <div
                    className={cn(
                      "whitespace-normal break-words markdown-content font-serif overflow-hidden px-1 mt-0.5",
                      !selectedMessage && parentId === null
                        ? ""
                        : isSelectedOrParent || siblingsArr.some((s) => s.id === selectedMessage)
                          ? ""
                          : message.replies.length > 0
                            ? message.isCollapsed
                              ? "border-l-2 rounded-bl-lg border-b-2 border-dashed ml-3"
                              : "border-l-2 ml-3"
                            : "ml-3.5"
                    )}
                    onDoubleClick={() => {
                  
                      cancelEditingMessage();
                      // 2. 再根据锁定状态，决定是否进入编辑
                     
                        startEditingMessage(message);  
                      }}
                  >
                    {message.isCollapsed ? (
                      <div className="flex flex-col">
                        <div>
                          {/* 关键改动处: 折叠时用 getPreviewString(...) 来简要预览 */}
                          {getPreviewString(message.content)}
                        </div>
                        {getTotalReplies(message) > 0 && (
                          <span className="dark:text-yellow-600 text-yellow-800">
                            {`(${getTotalReplies(message)} ${getTotalReplies(message) === 1 ? "reply" : "replies"
                              })`}
                          </span>
                        )}
                      </div>
                    ) : (
                      <div className="markdown-content">
                        {renderMessageContent(message.content, isSelected)}
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* 如果选中：显示操作按钮 */}
              {selectedMessage === message.id && (
                <div className="space-x-1 mt-1 flex flex-wrap items-center select-none">
                  {editingMessage === message.id ? (
                    <>
                      <Button
                        className="hover:bg-background transition-scale-zoom"
                        size="sm"
                        variant="ghost"
                        onClick={() => confirmEditingMessage(threadId, message.id)}
                      >
                        <Check className="h-4 w-4" />
                        <span className="hidden md:inline">
                          <MenubarShortcut>⌘ ↩</MenubarShortcut>
                        </span>
                      </Button>
                      <Button
                        className="hover:bg-background transition-scale-zoom"
                        size="sm"
                        variant="ghost"
                        onClick={cancelEditingMessage}
                      >
                        <X className="h-4 w-4" />
                        <span className="hidden md:inline">
                          <MenubarShortcut>Esc</MenubarShortcut>
                        </span>
                      </Button>
                    </>
                  ) : (
                    <>
                      {/* Reply */}
                      <Button
                        className="h-10 hover:bg-background transition-scale-zoom"
                        size="sm"
                        variant="ghost"
                        onClick={() => {
                          if (message.isCollapsed) {
                            toggleCollapse(threadId, message.id);
                          }
                          cancelEditingMessage();
                          setSelectedMessages((prev) => ({
                            ...prev,
                            [String(threadId)]: null,
                          }));
                          addEmptyReply(threadId, message.id);
                        }}
                      >
                        <MessageSquareReply className="h-4 w-4" />
                        <span className="hidden md:inline">Reply</span>
                      </Button>

                      {/* Generate or Stop */}
                      {isGenerating[message.id] ? (
                        <Button
                          size="sm"
                          variant="ghost"
                          className={cn(
                            "h-10 w-inherit relative group",
                            "hover:text-destructive-foreground hover:bg-destructive transition-scale-zoom"
                          )}
                          onClick={() => generateAIReply(threadId, message.id, 1)}
                        >
                          <span className="group-hover:hidden">
                            <LoaderCircle className="h-4 w-4 animate-spin" />
                          </span>
                          <span className="hidden group-hover:inline">
                            <OctagonX className="h-4 w-4" />
                          </span>
                          <span className="hidden md:inline ml-2 w-[59px]">
                            <span className="group-hover:hidden">Working</span>
                            <span className="hidden group-hover:inline">Stop</span>
                          </span>
                        </Button>
                      ) : (
                        <Menubar className="p-0 border-none bg-transparent">
                          <MenubarMenu>
                            <MenubarTrigger className="h-10 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900 transition-scale-zoom">
                              <WandSparkles className="h-4 w-4" />
                              <span className="hidden md:inline ml-2">Generate</span>
                            </MenubarTrigger>
                            <MenubarContent className="custom-shadow">
                              <MenubarItem
                                onClick={() => {
                                  if (message.isCollapsed) {
                                    toggleCollapse(threadId, message.id);
                                  }
                                  generateAIReply(threadId, message.id, 1);
                                }}
                              >
                                Once
                                <span className="hidden md:inline ml-auto">
                                  <MenubarShortcut>Enter</MenubarShortcut>
                                </span>
                              </MenubarItem>
                              <MenubarItem
                                onClick={() => {
                                  if (message.isCollapsed) {
                                    toggleCollapse(threadId, message.id);
                                  }
                                  generateAIReply(threadId, message.id, lastGenerateCount);
                                }}
                              >
                                {lastGenerateCount} times
                                <MenubarShortcut>{lastGenerateCount}×</MenubarShortcut>
                              </MenubarItem>
                              <MenubarItem
                                onClick={() => {
                                  if (message.isCollapsed) {
                                    toggleCollapse(threadId, message.id);
                                  }
                                  const times = prompt(
                                    "How many times? (1-10)",
                                    lastGenerateCount.toString()
                                  );
                                  const numTimes = parseInt(times || "0", 10);
                                  if (!isNaN(numTimes) && numTimes > 0 && numTimes <= 10) {
                                    setLastGenerateCount(numTimes);
                                    generateAIReply(threadId, message.id, numTimes);
                                  } else if (numTimes > 10) {
                                    setLastGenerateCount(10);
                                    generateAIReply(threadId, message.id, 10);
                                  }
                                }}
                              >
                                Custom
                              </MenubarItem>
                              <MenubarItem
                                onClick={() => {
                                  if (message.isCollapsed) {
                                    toggleCollapse(threadId, message.id);
                                  }
                                  addEmptyReply(threadId, message.id, "ai");
                                }}
                              >
                                Empty
                              </MenubarItem>
                            </MenubarContent>
                          </MenubarMenu>
                        </Menubar>
                      )}
{/*
<Button
  // variant、size、className 跟其他按钮相同
  variant="ghost"
  size="sm"
  className="h-10 hover:bg-background transition-scale-zoom"

  onClick={async (e) => {
    e.stopPropagation();
    cancelEditingMessage();
    if (!message.locked) {
      startEditingMessage(message);
    } else {
      // 如果锁定则直接走 handleSelectMessage
      await handleSelectMessage({
        message,
        setSelectedMessages,
        currentThread: currentThread || "",
        setThreads,
      });
    }
  }}
>

  <Edit className="h-4 w-4" />
  <span className="hidden md:inline">
    {message.locked ? "Editing" : "Edit"}
  </span>
</Button> */}
        

                     <Button
                        className="h-10 hover:bg-background transition-scale-zoom"
                        size="sm"
                        variant="ghost"
                        onClick={() => {
                          cancelEditingMessage();
                          startEditingMessage(message);
                        }}
                      >
                        <Edit className="h-4 w-4" />
                        <span className="hidden md:inline">Edit</span>
                      </Button> 

                      {/* Copy / Cut / Paste */}
                      <Menubar className="p-0 border-none bg-transparent">
                        <MenubarMenu>
                          <MenubarTrigger className="h-10 rounded-lg hover:bg-background transition-scale-zoom">
                            {clipboardMessage ? (
                              <ClipboardCheck className="h-4 w-4" />
                            ) : (
                              <Copy className="h-4 w-4" />
                            )}
                            <span className="hidden md:inline ml-2">
                              {clipboardMessage?.operation === "cut"
                                ? "Cutting"
                                : clipboardMessage
                                  ? "Copying"
                                  : "Copy"}
                            </span>
                          </MenubarTrigger>
                          <MenubarContent className="custom-shadow">
                            {clipboardMessage ? (
                              <>
                                <MenubarItem onClick={() => pasteMessage(threadId, message.id)}>
                                  Paste Message
                                  <span className="hidden md:inline ml-auto">
                                    <MenubarShortcut>⌘ V</MenubarShortcut>
                                  </span>
                                </MenubarItem>
                                <MenubarItem
                                  onClick={() => {
                                    clearGlowingMessages();
                                    setClipboardMessage(null);
                                  }}
                                >
                                  Clear Clipboard
                                  <span className="hidden md:inline ml-auto">
                                    <MenubarShortcut>Esc</MenubarShortcut>
                                  </span>
                                </MenubarItem>
                              </>
                            ) : (
                              <>
                                <MenubarItem
                                  onClick={() => copyOrCutMessage(threadId, message.id, "copy")}
                                >
                                  Copy
                                  <span className="hidden md:inline ml-auto">
                                    <MenubarShortcut>⌘ C</MenubarShortcut>
                                  </span>
                                </MenubarItem>
                                <MenubarItem
                                  onClick={() => copyOrCutMessage(threadId, message.id, "cut")}
                                >
                                  Cut
                                  <span className="hidden md:inline ml-auto">
                                    <MenubarShortcut>⌘ X</MenubarShortcut>
                                  </span>
                                </MenubarItem>
                              </>
                            )}
                          </MenubarContent>
                        </MenubarMenu>
                      </Menubar>

                      {/* Delete */}
                      <Menubar className="p-0 border-none bg-transparent">
                        <MenubarMenu>
                          <MenubarTrigger className="h-10 rounded-lg hover:bg-destructive transition-scale-zoom">
                            <Trash className="h-4 w-4" />
                            <span className="hidden md:inline ml-2">Delete</span>
                          </MenubarTrigger>
                          <MenubarContent className="custom-shadow">
                            {message.replies && message.replies.length > 0 ? (
                              <>
                                <MenubarItem
                                  onClick={() => deleteMessage(threadId, message.id, false)}
                                >
                                  Keep Replies
                                  <MenubarShortcut className="hidden md:inline">⌫</MenubarShortcut>
                                </MenubarItem>
                                <MenubarItem
                                  onClick={() => deleteMessage(threadId, message.id, true)}
                                >
                                  With Replies
                                  <MenubarShortcut className="hidden md:inline">
                                    ⌘ ⌫
                                  </MenubarShortcut>
                                </MenubarItem>
                                <MenubarItem
                                  onClick={() => deleteMessage(threadId, message.id, "clear")}
                                >
                                  Only Replies
                                  <MenubarShortcut className="hidden md:inline">
                                    ⌥ ⌫
                                  </MenubarShortcut>
                                </MenubarItem>
                              </>
                            ) : (
                              <MenubarItem
                                onClick={() => deleteMessage(threadId, message.id, false)}
                              >
                                Delete
                                <MenubarShortcut className="hidden md:inline">⌫</MenubarShortcut>
                              </MenubarItem>
                            )}
                          </MenubarContent>
                        </MenubarMenu>
                      </Menubar>
                    </>
                  )}
                </div>
              )}
            </div>
          </div>
        </ContextMenuTrigger>

        {/* 右键菜单内容 */}
        <ContextMenuContent className="custom-shadow bg-background/90">
          <ContextMenuItem
            onClick={() => {
              if (message.isCollapsed) {
                toggleCollapse(threadId, message.id);
              }
              addEmptyReply(threadId, message.id);
            }}
          >
            <MessageSquareReply className="h-4 w-4 mr-2" />
            Reply
            <ContextMenuShortcut className="hidden md:inline">R</ContextMenuShortcut>
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              if (message.isCollapsed) {
                toggleCollapse(threadId, message.id);
              }
              generateAIReply(threadId, message.id, 1);
            }}
          >
            <WandSparkles className="h-4 w-4 mr-2" />
            Generate
            <ContextMenuShortcut className="hidden md:inline">Enter</ContextMenuShortcut>
          </ContextMenuItem>
          <ContextMenuItem
           onClick={() => {
            cancelEditingMessage();
        
            startEditingMessage(message);
          }}
        >
            <Edit className="h-4 w-4 mr-2" />
            Edit
            <ContextMenuShortcut className="hidden md:inline">E</ContextMenuShortcut>
          </ContextMenuItem>
          <ContextMenuSeparator />
          <ContextMenuItem onClick={() => copyOrCutMessage(threadId, message.id, "copy")}>
            <Copy className="h-4 w-4 mr-2" />
            Copy
            <ContextMenuShortcut className="hidden md:inline">⌘ C</ContextMenuShortcut>
          </ContextMenuItem>
          <ContextMenuItem onClick={() => copyOrCutMessage(threadId, message.id, "cut")}>
            <Scissors className="h-4 w-4 mr-2" />
            Cut
            <ContextMenuShortcut className="hidden md:inline">⌘ X</ContextMenuShortcut>
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              pasteMessage(threadId, message.id);
              setClipboardMessage(null);
            }}
          >
            {clipboardMessage ? <ClipboardPaste className="mr-2 h-4 w-4" /> : <ClipboardType className="mr-2 h-4 w-4" />}
            <span>{clipboardMessage ? "Paste Message" : "Paste Clipboard"}</span>
            <ContextMenuShortcut className="hidden md:inline ml-2">⌘ V</ContextMenuShortcut>
          </ContextMenuItem>
          {clipboardMessage && (
            <ContextMenuItem
              onClick={() => {
                clearGlowingMessages();
                setClipboardMessage(null);
              }}
            >
              <ClipboardX className="mr-2 h-4 w-4" />
              <span>Clear {clipboardMessage.operation === "cut" ? "Cut" : "Copied"}</span>
              <ContextMenuShortcut className="hidden md:inline">Esc</ContextMenuShortcut>
            </ContextMenuItem>
          )}
          <ContextMenuSeparator />
          <ContextMenuLabel>Delete</ContextMenuLabel>
          <ContextMenuItem
            className="text-red-500"
            onClick={() => deleteMessage(threadId, message.id, false)}
          >
            <Trash className="h-4 w-4 mr-2" />
            Keep Replies
            <ContextMenuShortcut className="hidden md:inline">⌫</ContextMenuShortcut>
          </ContextMenuItem>
          {message.replies?.length > 0 && (
            <>
              <ContextMenuItem
                className="text-red-500"
                onClick={() => deleteMessage(threadId, message.id, true)}
              >
                <Trash2 className="h-4 w-4 mr-2" />
                With Replies
                <ContextMenuShortcut className="hidden md:inline">⌘ ⌫</ContextMenuShortcut>
              </ContextMenuItem>
              <ContextMenuItem
                className="text-red-500"
                onClick={() => deleteMessage(threadId, message.id, "clear")}
              >
                <MessageSquareOff className="h-4 w-4 mr-2" />
                Only Replies
                <ContextMenuShortcut className="hidden md:inline">⌥ ⌫</ContextMenuShortcut>
              </ContextMenuItem>
            </>
          )}
        </ContextMenuContent>
      </ContextMenu>

      {/* 子消息 */}
      <AnimatePresence>
        {!message.isCollapsed && (
          <motion.div layout="position" transition={{ duration: 0.1 }}>
            {message.replies.map((reply) => (
              <div
                key={reply.id}
                className={cn(
                  "ml-4",
                  !isParentOfSelected &&
                  cn(
                    "relative",
                    "before:absolute before:left-0 before:-top-2 before:w-[17px] before:h-10",
                    "before:border-b-2 before:border-l-2 before:border-border before:rounded-bl-lg",
                    getSiblings(message.replies, reply.id).slice(-1)[0].id !== reply.id &&
                    "after:absolute after:left-0 after:top-5 after:-bottom-0 after:border-l-2 after:border-border"
                  )
                )}
              >
                {/* 递归调用 RenderMessage */}
                <RenderMessage
                  {...props}
                  key={reply.id}
                  message={reply}
                  parentId={message.id}
                  depth={depth + 1}
                />
              </div>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
};

export default RenderMessage;